I"Â,<h2>The Problem</h2>
<p>Recently at <a href="https://www.earthclassmail.com/" target="_blank">EarthClassMail</a> we wanted to migrate our ‚ÄúPDF generator‚Äù system to Azure, so I began researching our options.  There are plenty of solutions out there that create PDFs from images, but we also needed OCR results to make the PDF ‚Äúsearchable‚Äù.  I figured we‚Äôd be able to locate a .Net library that would do the trick.  Or possibly an affordable service that offered a cloud-based API to generate PDFs‚Ä¶</p>

<p>Boy was I wrong!  After browsing a multitude of possible solutions, I classified them into 3 groups:</p>

<ol>
  <li>Too simple - mainly because they didn‚Äôt include the OCR/searchable part.</li>
  <li>Too old - utilizing DllInclude and COM Interops that I didn‚Äôt want to attempt in Azure.</li>
  <li>Too expensive - there were some that appeared to give us what we need, but they demanded an arm, a leg, and a pound of flesh to use.</li>
</ol>

<p>I began to lose hope‚Ä¶then I expanded my google search to ‚Äúnon .Net‚Äù solutions.</p>

<p>Enter <a href="https://github.com/jbarlow83/OCRmyPDF" target="_blank">OCRmyPDF</a>!</p>

<h2>OCRmyPDF and Tesseract</h2>
<p>Unbeknownst to me during all my fruitless searching, there are some really awesome open source libraries that had all we needed, with a catch - they don‚Äôt run on .Net!</p>

<p>OCRmyPDF jumped out at me with quality documentation, and a simple setup (via <a href="https://www.docker.com/" target="_blank">Docker</a>).  It consisted of the following:</p>

<ol>
  <li>Docker image based on <a href="https://www.ubuntu.com/" target="_blank">Ubuntu</a> (a popular flavor of Linux)</li>
  <li>The image contained <a href="https://en.wikipedia.org/wiki/Tesseract_(software)" target="_blank">Tesseract</a>, a powerful OCR library.</li>
  <li>A <a href="https://www.python.org/" target="_blank">Python</a> wrapper allowing easy invocation of Tesseract from the command line.</li>
</ol>

<p>I knew a little about Docker, and less about Python, but was intrigued.  Could I solve this problem with open source and Docker?  After a little more searching, I found another library (<a href="https://github.com/sseemayer/OCRmyPDF-web" target="_blank">OCRmyPDF-web</a>) where a brave soul had wrapped the above in a simple REST layer (and even more simple front end).  With a little hacking, I could basically host my own PDF-generating service!  But how to ‚Äúexpose‚Äù this within Azure?</p>

<p>
<img src="/images/speediest/shoulders_of_giants.png" alt="Seeing far on shoulders of giants" />
<em>Seeing far on shoulders of giants</em>
</p>

<h2>Docker In Azure</h2>
<p>Turns out, the answer is ‚Äúeasily‚Äù.  The development process consisted of a few steps:</p>

<ol>
  <li>Get the code working locally (using Docker).</li>
  <li>Follow <a href="https://docs.microsoft.com/en-us/azure/app-service/containers/tutorial-custom-docker-image" target="_blank">these instructions</a> to host your container within an Azure Web App.</li>
</ol>

<p>While there was some elbow grease required to work through the exercise (learning python on the fly, working through errors, etc), it was <em>mostly</em> straightforward (and frankly, a little amazing after all my fruitless research into available .Net solutions).</p>

<p>Here are the details:</p>

<h3>Speediest PDF</h3>
<p>I created the <a href="https://github.com/martyice/speediestpdf" target="_blank">SpeediestPDF</a> repo to demo the python script I cobbled together (say ‚ÄúSpeediest PDF‚Äù a few times out loud to yourself.  I‚Äôm pretty proud of this rhyming name).  Pull it and take a look around some of the files:</p>

<ul>
  <li>Dockerfile - used to build the Docker image</li>
  <li>entrypoint.sh - launches the Docker container</li>
  <li>requirements.txt - list of libraries needed to run python script</li>
  <li>server.py - actual python code that establishes the REST API</li>
</ul>

<p>Build it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> martyice/speediestpdf <span class="nb">.</span>
</code></pre></div></div>

<p>Fire it up with something like this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-e</span> <span class="nv">azureAccountName</span><span class="o">=</span>&lt;AzureStorageName&gt; <span class="nt">-e</span> <span class="nv">azureAccountKey</span><span class="o">=</span>&lt;AzureStorageKey&gt; <span class="nt">-e</span> <span class="nv">appInsightsTelemetryKey</span><span class="o">=</span>&lt;AppInsightsKey&gt; <span class="nt">-p</span> 8888:8000 martyice/speediestpdf
</code></pre></div></div>

<p>Once it‚Äôs running successfully, you can use the wonderful <a href="https://www.getpostman.com/" target="_blank">Postman</a> to test it out:</p>

<p>
<img src="/images/speediest/postman_trigger.png" alt="Wait a Minute Mr. Postman!" />
<em>Wait a Minute Mr. Postman!</em>
</p>

<h3>Docker Pro Tips</h3>
<p>As I hacked throught this solution, I discovered some things about Docker that improved my development experience.  I‚Äôm sharing them here in case they help you:</p>

<ul>
  <li>You don‚Äôt need to name your container.  I started out using the ‚Äú‚Äìname‚Äù option when I‚Äôd run my container, but it caused issues if I wanted to run multiple times (eg, ‚Äúthe container name ‚Äú/test‚Äù is already in use by container‚Ä¶‚Äù).  If you‚Äôre just testing this stuff locally, you don‚Äôt need the name.</li>
  <li>To stop and remove all running containers, run this super handy set of commands:
    <ol>
      <li>docker stop $(docker ps -aq)</li>
      <li>docker rm $(docker ps -aq)</li>
      <li>docker rmi $(docker images -q)   <em>note - this one is more invasive!</em></li>
    </ol>
  </li>
</ul>

<p>There‚Äôs a whole world of things to learn with Docker, but these commands drastically sped up my iterations, and eliminated alot of frustration.</p>

<h3>Push to Azure</h3>
<p>Once your satisfied with how it works locally, time to take your act on the road!  The instructions for <a href="https://docs.microsoft.com/en-us/azure/app-service/containers/tutorial-custom-docker-image" target="_blank">pushing to Azure</a> are easy to follow.  They utilize <a href="https://hub.docker.com/" target="_blank">DockerHub</a>, which is much like <a href="https://github.com/" target="_blank">Github</a>, except instead of storing source code, it stores, versions, and shares Docker images.  Eventually you might want to put your top secret, masterfully crafted Docker image in a private repository (in DockerHub, Azure, or elsewhere), but for this exercise, we just need it publicly accessible.  <a href="https://ropenscilabs.github.io/r-docker-tutorial/04-Dockerhub.html" target="_blank">These instructions</a> walk you through it.</p>

<ol>
  <li>Tag your Docker image:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker tag &lt;imageIdentifier&gt; &lt;yourDockerHubUserName&gt;/speediestpdf:demo
</code></pre></div>    </div>
  </li>
  <li>Push the Docker image to DockerHub:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker push &lt;yourDockerHubUserName&gt;/speediestpdf
</code></pre></div>    </div>
  </li>
  <li>
    <p>Use <a href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest" target="_blank">AzureCLI</a> to login to your Azure account.</p>
  </li>
  <li>Create a resource group:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az group create --name MySpeediestPDF --location "westus2"
</code></pre></div>    </div>
  </li>
  <li>Create Linux service plan:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az appservice plan create --name MySpeediestPDF --resource-group MySpeediestPDF --sku B1 --is-linux
</code></pre></div>    </div>
  </li>
  <li>Create a web app.  Note the ‚Äúdeployment-container-image-name‚Äù argument - this instructs Azure to pull down the Docker image you stored in Docker Hub earlier, and use it in the web app.  Cool stuff!
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az webapp create --resource-group MySpeediestPDF --plan MySpeediestPDF --name MySpeediestPDF --deployment-container-image-name &lt;yourDockerHubUserName&gt;/speediestpdf:demo
</code></pre></div>    </div>
    <p><em>note your ‚Äúapp_name‚Äù value will actually be publicly accessible from Azure, so you‚Äôll need something unique.  ‚Äútest‚Äù probably won‚Äôt make the grade.</em></p>
  </li>
  <li>IMPORTANT - Configuration Environment variables.  I missed this step the first time through.  It‚Äôs necessary to expose your Docker image‚Äôs port to the Azure web service port:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>az webapp config appsettings set --resource-group MySpeediestPDF --name &lt;app_name&gt; --settings WEBSITES_PORT=8000
</code></pre></div>    </div>
    <p>You‚Äôll also need to set values for the following variables (these are environment variables within the python script):</p>
    <ul>
      <li>azureAccountName</li>
      <li>azureAccountKey</li>
      <li>appInsightsTelemetryKey
¬†</li>
    </ul>
  </li>
  <li>With all this in place‚Ä¶SUCCESS!</li>
</ol>
<p>
<img src="/images/speediest/success.png" alt="Success!" />
<em>Success!</em>
</p>

<h3>Debugging and Tracing</h3>
<p>There are a few places to look when things don‚Äôt work correctly‚Ä¶</p>

<ul>
  <li>Container Settings - within Azure Portal, you can view the logs generated when starting your container in the ‚ÄúContainer Settings‚Äù section of your app service:</li>
</ul>
<p>
<img src="/images/speediest/container_settings.png" alt="Container Settings" />
<em>Helpful Container settings</em>
</p>

<ul>
  <li>App Insights - as always, Azure App Insights can shed light on what‚Äôs happening within your Docker container.  If you examine the Python source code in this exercise, you‚Äôll see it‚Äôs logging helpful information to App Insights.  Search the Traces and Exceptions logs to gain insight into what your python script is up to.</li>
</ul>

<h2>Disclaimer</h2>
<p>It‚Äôs worth noting that this solution is a step towards a production ready solution, but is probably not recommended for actual production use.  Some things to consider:</p>

<ol>
  <li><a href="http://www.hug.rest/" target="_blank">Hug</a> is a great development library for enabling REST in a Python application, but is not really intended for production volume.  There are details in the Hug documentation on what to change and use when you‚Äôre ready for that.</li>
  <li>Security, security, security - there is currently none.  Unwise for production, otherwise your service will attract the attention of baddies.</li>
  <li>Scalability - this example is single threaded, and not tuned in any way.  If you need to support volume, you‚Äôd want to invest time and attention to that.</li>
</ol>

<p>Ultimately, we ended up using a variant of this solution at EarthClassMail, one that launched ‚Äúbatch processing‚Äù Docker containers on the fly to respond to requests.  It was a barrel of fun to work on, but that‚Äôs for another post.</p>

<p>Happy Docker/Python/Azure/PDF-ing!</p>

:ET